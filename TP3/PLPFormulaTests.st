TestCase subclass: #Ej1KindOfTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PLPFormulaTests'!!Ej1KindOfTest methodsFor: 'testing' stamp: 'PLP 6/3/2016 10:25'!test02allFormulasAreFormulas| p q r f1 f2 f3 f4 |p := PropositionalVariable named: #P.q := PropositionalVariable named: #Q.r := PropositionalVariable named: #R.f1 := Negation of: p.f2 := Conjunction of: f1 and: q.f3 := Disjunction of: p and: r.f4 := Implication of: f3 and: r.self assert: (r isKindOf: PropositionalVariable).self assert: (f1 isKindOf: PropositionalFormula).self assert: (f2 isKindOf: PropositionalFormula).self assert: (f3 isKindOf: PropositionalFormula).self assert: (f4 isKindOf: PropositionalFormula).! !!Ej1KindOfTest methodsFor: 'testing' stamp: 'PLP 6/3/2016 10:24'!test01EachFormulaTypeIsKindOfItsOwnClass| p q r f1 f2 f3 f4 |p := PropositionalVariable named: #P.q := PropositionalVariable named: #Q.r := PropositionalVariable named: #R.f1 := Negation of: p.f2 := Conjunction of: f1 and: q.f3 := Disjunction of: p and: r.f4 := Implication of: f3 and: r.self assert: (r isKindOf: PropositionalVariable).self assert: (f1 isKindOf: Negation).self assert: (f2 isKindOf: Conjunction).self assert: (f3 isKindOf: Disjunction).self assert: (f4 isKindOf: Implication).! !TestCase subclass: #Ej2AllPropVarsTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PLPFormulaTests'!!Ej2AllPropVarsTest methodsFor: 'testing' stamp: 'PLP 6/3/2016 10:36'!test03PropositionalVariablesAreEnumeratedCorrectly| p q r  f1 f2 f3 f4 f5 vars1 vars2|p := PropositionalVariable named: #P.q := PropositionalVariable named: #Q.r := PropositionalVariable named: #R.vars1 := Set with: #P with: #Q.vars2 := Set with: #P with: #Q with: #R.f1 := Conjunction of: p and: q.f2 := Disjunction of: p and: q.f3 := Negation of: r.f4 := Implication of: f1 and: f2.f5 := Negation of: (Conjunction of: f4 and: (Disjunction of: p and: f3)).self assert: f1 allPropVars = vars1.self assert: f2 allPropVars = vars1.self assert: f3 allPropVars = (Set with: #R).self assert: f4 allPropVars = vars1.self assert: f5 allPropVars = vars2.! !TestCase subclass: #Ej3ValueTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PLPFormulaTests'!!Ej3ValueTest methodsFor: 'testing' stamp: 'PLP 6/3/2016 10:49'!test04FormulasAreEvaluatedCorrectly| p q r f1 f2 f3 f4 f5 vars1 vars2 vars3|p := PropositionalVariable named: #P.q := PropositionalVariable named: #Q.r := PropositionalVariable named: #R.vars1 := Set with: #P with: #Q.vars2 := Set with: #Q with: #R.vars3 := Set with: #P with: #Q with: #R.f1 := Conjunction of: p and: q.f2 := Disjunction of: p and: q.f3 := Negation of: r.f4 := Implication of: f1 and: f2.f5 := Implication of: f1 and: r.self assert: (f1 value: vars1).self assert: (f1 value: vars2) not.self assert: (f1 value: vars3).self assert: (f2 value: vars1).self assert: (f2 value: vars2).self assert: (f2 value: vars3).self assert: (f2 value: Set new) not.self assert: (f3 value: vars1).self assert: (f3 value: vars2) not.self assert: (f4 value: vars1).self assert: (f4 value: vars2).self assert: (f4 value: vars3).self assert: (f4 value: Set new).self assert: (f5 value: Set new).self assert: (f5 value: vars1) not.self assert: (f5 value: vars2).self assert: (f5 value: vars3).! !TestCase subclass: #Ej4PrettyFormulaConstructionTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PLPFormulaTests'!!Ej4PrettyFormulaConstructionTest methodsFor: 'testing' stamp: 'PLP 6/3/2016 10:55'!test05WeCanBuildPrettyFormulas|p q r|p := PropositionalVariable named: #P.q := PropositionalVariable named: #Q.r := PropositionalVariable named: #R.self assert: (p not isKindOf: Negation).self assert: (q & r isKindOf: Conjunction).self assert: (p | (q & r) isKindOf: Disjunction).self assert: ((p | q) ==> r isKindOf: Implication).! !TestCase subclass: #Ej5StringConversionTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PLPFormulaTests'!!Ej5StringConversionTest methodsFor: 'testing' stamp: 'GiselaConfalonieri 6/13/2016 17:49'!test06WeCanConvertFormulasToStrings	| p q r  f1 f2 f3 f4 f5 |p := PropositionalVariable named: #P.q := PropositionalVariable named: #Q.r := PropositionalVariable named: #R.f1 := p & q.f2 := r not.f3 := f1 ==> f2.f4 := ((( p & q ) ==> ( p | q )) & ( p | r not))not.f5 := ((p ==> q) & r & (p & q not | r not)) not.self assert: f1 asString equals: 'P & Q'.self assert: f2 asString equals: '¬R'.self assert: f3 asString equals: '( P & Q ) ==> ¬R'.self assert: f4 asString equals: '¬( ( ( P & Q ) ==> ( P | Q ) ) & ( P | ¬R ) )'.self assert: f5 asString equals: '¬( ( ( P ==> Q ) & R ) & ( ( P & ¬Q ) | ¬R ) )'.! !!Ej5StringConversionTest methodsFor: 'testing' stamp: 'PLP 6/3/2016 11:05'!test07FormulasShowAsTheirStringRepresentation	| p q r  f1 f2 f3 f4 f5 |p := PropositionalVariable named: #P.q := PropositionalVariable named: #Q.r := PropositionalVariable named: #R.f1 := p & q.f2 := r not.f3 := f1 ==> f2.f4 := ((( p & q ) ==> ( p | q )) & ( p | r not))not.f5 := ((p ==> q) & r & (p & q not | r not)) not.self assert: f1 printString equals: 'P & Q'.self assert: f2 printString equals: '¬R'.self assert: f3 printString equals: '( P & Q ) ==> ¬R'.self assert: f4 printString equals: '¬( ( ( P & Q ) ==> ( P | Q ) ) & ( P | ¬R ) )'.self assert: f5 printString equals: '¬( ( ( P ==> Q ) & R ) & ( ( P & ¬Q ) | ¬R ) )'.! !TestCase subclass: #Ej6EqualityTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PLPFormulaTests'!!Ej6EqualityTest methodsFor: 'testing' stamp: 'PLP 6/3/2016 11:22'!test08WeCanCompareFormulas	| p q r f1 f2 f3 f4 f5 |	p := PropositionalVariable named: #P.	q := PropositionalVariable named: #Q.	r := PropositionalVariable named: #R.	f1 := p & q.	f2 := r not.	f3 := f1 ==> f2.	f4 := ((p & q) ==> (p | q) & (p | r not)) not.	f5 := Disjunction of: r and: f3.	self assert: f1 equals: (Conjunction of: p and: q).	self assert: f2 equals: (Negation of: r).	self assert: f3 equals: (Implication of: f1 and: f2).	self		assert: ((Conjunction of: (Conjunction of: p and: q) ==> (Disjunction of: p and: q) and: (Disjunction of: p and: (Negation of: r)))) not		equals: f4.	self assert: f5 equals: r | ((p & q) ==> f2).	self assert: f1 ~= f2.	self assert: p ~= q.	self assert: f4 ~= f5.	self assert: f4 ~= f2! !!Ej6EqualityTest methodsFor: 'testing' stamp: 'PLP 6/3/2016 11:26'!test09WeCanUseHash	| p q r f1 f2 f3 f4 f5 |	p := PropositionalVariable named: #P.	q := PropositionalVariable named: #Q.	r := PropositionalVariable named: #R.	f1 := p & q.	f2 := r not.	f3 := f1 ==> f2.	f4 := ((p & q) ==> (p | q) & (p | r not)) not.	f5 := Disjunction of: r and: f3.	self assert: f1 hash equals: (Conjunction of: p and: q) hash.	self assert: f2 hash equals: (Negation of: r) hash.	self assert: f3 hash equals: (Implication of: f1 and: f2) hash.	self		assert: ((Conjunction of: (Conjunction of: p and: q) ==> (Disjunction of: p and: q) and: (Disjunction of: p and: (Negation of: r)))) not hash		equals: f4 hash.	self assert: f5 hash equals: (r | ((p & q) ==> f2)) hash.	self assert: f1 hash ~= f2 hash.	self assert: p hash ~= q hash.	self assert: f4 hash ~= f5 hash.	self assert: f4 hash ~= f2 hash! !TestCase subclass: #Ej7NegatedNormalFormTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PLPFormulaTests'!!Ej7NegatedNormalFormTest methodsFor: 'testing' stamp: 'PLP 6/3/2016 11:39'!test11NNFofNegationBehavesCorrectly| p q r f1 f2 f3 f4 f5 |p := PropositionalVariable named: #P.q := PropositionalVariable named: #Q.r := PropositionalVariable named: #R.f1 := p & q.f2 := p | q.f3 := r not not.f4 := f1 ==> f2.f5 := ((p ==> q) & r & (p & q not | r not)) not.self assert: f1 not toNNF equals: f1 toNNF negate.self assert: f2 not toNNF equals: f2 toNNF negate.self assert: f3 not toNNF equals: f3 toNNF negate.self assert: f4 not toNNF equals: f4 toNNF negate.self assert: f5 not toNNF equals: f5 toNNF negate.! !!Ej7NegatedNormalFormTest methodsFor: 'testing' stamp: 'PLP 6/3/2016 11:36'!test10WeCanConvertToNegatedNormalForm| p q r f1 f2 f3 f4 f5 |p := PropositionalVariable named: #P.q := PropositionalVariable named: #Q.r := PropositionalVariable named: #R.f1 := p & q.f2 := p | q.f3 := r not not.f4 := f1 ==> f2.f5 := ((p ==> q) & r & (p & q not | r not)) not.self assert: f1 toNNF equals: f1.self assert: f2 toNNF equals: f2.self assert: f3 toNNF equals: r.self assert: f4 toNNF equals: ( p not | q not ) | ( p | q ).self assert: f5 toNNF equals: ( ( p & q not ) | r not ) | ( ( p not | q ) & r ).! !!Ej7NegatedNormalFormTest methodsFor: 'testing' stamp: 'PLP 6/3/2016 11:31'!test09WeCanNegateFormulas| p q r f1 f2 f3 f4 f5 |p := PropositionalVariable named: #P.q := PropositionalVariable named: #Q.r := PropositionalVariable named: #R.f1 := p & q.f2 := p | q.f3 := r not.f4 := f1 ==> f2.f5 := ((p ==> q) & r & (p & q not | r not)) not.self assert: f1 negate equals: p not | q not.self assert: f2 negate equals: p not & q not.self assert: f3 negate equals: r.self assert: f4 negate equals: ( p & q ) & ( p not & q not ).self assert: f5 negate equals: ( ( p ==> q ) & r ) & ( ( p & q not ) | r not ).! !PackageManifest subclass: #ManifestPLPFormulaTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PLPFormulaTests'!!ManifestPLPFormulaTests commentStamp: '<historical>' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ManifestPLPFormulaTests class	instanceVariableNames: ''!!ManifestPLPFormulaTests class methodsFor: 'code-critics' stamp: 'PLP 6/3/2016 10:49'!ruleRBLongMethodsRuleV1FalsePositive	^ #(#(#(#RGClassDefinition #(#Ej3ValueTest)) #'2016-06-03T10:49:56.479266-03:00') )! !Object subclass: #PropositionalFormula	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PLPFormulaTests'!!PropositionalFormula methodsFor: 'evaluating' stamp: 'GiselaConfalonieri 6/13/2016 13:42'!evaluar: aCollection operador: aString argumentos: aPropositionalFormula y: otherPropositionalFormula	| m |	m := Message selector: aString argument: (otherPropositionalFormula value: aCollection).	^ m sendTo: (aPropositionalFormula value: aCollection )! !!PropositionalFormula methodsFor: 'creation' stamp: 'GiselaConfalonieri 6/13/2016 13:51'!| aPropositionalFormula	^ Disjunction of: self and: aPropositionalFormula ! !!PropositionalFormula methodsFor: 'creation' stamp: 'GiselaConfalonieri 6/13/2016 13:48'!not	^ Negation of: self ! !!PropositionalFormula methodsFor: 'creation' stamp: 'GiselaConfalonieri 6/13/2016 13:50'!& aPropositionalFormula 	^ Conjunction of: self and: aPropositionalFormula ! !!PropositionalFormula methodsFor: 'creation' stamp: 'GiselaConfalonieri 6/13/2016 13:52'!==> aPropositionalFormula 	^ Implication of: self and: aPropositionalFormula ! !!PropositionalFormula methodsFor: 'as yet unclassified' stamp: 'GiselaConfalonieri 6/13/2016 18:48'!hash	^ self asString hash! !!PropositionalFormula methodsFor: 'as yet unclassified' stamp: 'AlejandroMignanelli 6/13/2016 18:42'!= formula	^ (self asString) = (formula asString)! !!PropositionalFormula methodsFor: 'as yet unclassified' stamp: 'AlejandroMignanelli 6/20/2016 19:41'!comoString	"solo se usa para poner los paréntesis"	^ '( ', self asString, ' )'! !!PropositionalFormula methodsFor: 'as yet unclassified' stamp: 'GiselaConfalonieri 6/13/2016 17:47'!asStringDe: aFormula and: otherFormula withSymbol: symbolString	^ (aFormula comoString),symbolString,(otherFormula comoString)! !!PropositionalFormula methodsFor: 'as yet unclassified' stamp: 'GiselaConfalonieri 6/13/2016 17:57'!printString	^ self asString! !PropositionalFormula subclass: #Conjunction	instanceVariableNames: 'form1 form2'	classVariableNames: ''	poolDictionaries: ''	category: 'PLPFormulaTests'!!Conjunction methodsFor: 'evaluating' stamp: 'AlejandroMignanelli 6/20/2016 19:49'!value: aCollection 	"se resuelve con un método de PropositionalFormula para evitar repetir código"	^ super evaluar: aCollection operador: #& argumentos: form1 y: form2	! !!Conjunction methodsFor: 'as yet unclassified' stamp: 'GiselaConfalonieri 6/13/2016 19:40'!toNNF	^ form1 toNNF & form2 toNNF! !!Conjunction methodsFor: 'as yet unclassified' stamp: 'GiselaConfalonieri 6/13/2016 18:56'!negate	^ (form1 negate) | (form2 negate)! !!Conjunction methodsFor: 'as yet unclassified' stamp: 'AlejandroMignanelli 6/20/2016 19:47'!asString	"se resuelve con un método de PropositionalFormula para evitar repetir código"	^ super asStringDe: form1 and: form2  withSymbol: ' & '! !!Conjunction methodsFor: 'as yet unclassified' stamp: 'AlejandroMignanelli 6/20/2016 19:46'!allPropVars	| f |	f := form1 allPropVars.	f addAll: (form2 allPropVars).	^ f 	"devolvemos f y no f addAll: ... porque addAll devuelve su parámetro y nos interesa devolver f"! !!Conjunction methodsFor: 'initialization' stamp: 'GiselaConfalonieri 6/11/2016 16:38'!initConjof: aPropositionalFormula and: otherPropositionalFormula 	form1 := aPropositionalFormula.	form2 := otherPropositionalFormula ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Conjunction class	instanceVariableNames: ''!!Conjunction class methodsFor: 'creating' stamp: 'GiselaConfalonieri 6/11/2016 16:36'!of: aPropositionalFormula and: otherPropositionalFormula	^ self new initConjof: aPropositionalFormula and: otherPropositionalFormula ! !PropositionalFormula subclass: #Disjunction	instanceVariableNames: 'form1 form2'	classVariableNames: ''	poolDictionaries: ''	category: 'PLPFormulaTests'!!Disjunction methodsFor: 'as yet unclassified' stamp: 'GiselaConfalonieri 6/13/2016 19:41'!toNNF	^ form1 toNNF | form2 toNNF! !!Disjunction methodsFor: 'as yet unclassified' stamp: 'GiselaConfalonieri 6/13/2016 18:59'!negate	^ (form1 negate) & (form2 negate)! !!Disjunction methodsFor: 'as yet unclassified' stamp: 'AlejandroMignanelli 6/20/2016 19:52'!asString	"se resuelve con un método de PropositionalFormula para evitar repetir código"	^ super asStringDe: form1 and: form2  withSymbol: ' | '! !!Disjunction methodsFor: 'as yet unclassified' stamp: 'AlejandroMignanelli 6/20/2016 19:51'!allPropVars	| f |	f := form1 allPropVars.	f addAll: (form2 allPropVars).	^ f	"devolvemos f y no f addAll: ... porque addAll devuelve su parámetro y nos interesa devolver f"! !!Disjunction methodsFor: 'evaluating' stamp: 'AlejandroMignanelli 6/20/2016 19:52'!value: aCollection 	"se resuelve con un método de PropositionalFormula para evitar repetir código"	^ super evaluar: aCollection operador: #| argumentos: form1 y: form2! !!Disjunction methodsFor: 'initializing' stamp: 'GiselaConfalonieri 6/11/2016 16:41'!initDisjof: aPropositionalFormula and: otherPropositionalFormula	form1 := aPropositionalFormula.	form2 := otherPropositionalFormula ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Disjunction class	instanceVariableNames: ''!!Disjunction class methodsFor: 'creating' stamp: 'GiselaConfalonieri 6/11/2016 17:58'!of: aPropositionalFormula and: otherPropositionalFormula	^ self new initDisjof: aPropositionalFormula and: otherPropositionalFormula ! !PropositionalFormula subclass: #Implication	instanceVariableNames: 'form1 form2'	classVariableNames: ''	poolDictionaries: ''	category: 'PLPFormulaTests'!!Implication methodsFor: 'as yet unclassified' stamp: 'GiselaConfalonieri 6/13/2016 19:17'!toNNF	^ form1 negate | form2! !!Implication methodsFor: 'as yet unclassified' stamp: 'GiselaConfalonieri 6/13/2016 19:00'!negate	^ form1 & (form2 negate)! !!Implication methodsFor: 'as yet unclassified' stamp: 'AlejandroMignanelli 6/20/2016 19:52'!asString	"se resuelve con un método de PropositionalFormula para evitar repetir código"	^ super asStringDe: form1 and: form2  withSymbol: ' ==> '! !!Implication methodsFor: 'as yet unclassified' stamp: 'AlejandroMignanelli 6/20/2016 19:51'!allPropVars	| f |	f := form1 allPropVars.	f addAll: (form2 allPropVars).	^ f	"devolvemos f y no f addAll: ... porque addAll devuelve su parámetro y nos interesa devolver f"! !!Implication methodsFor: 'evaluating' stamp: 'AlejandroMignanelli 6/20/2016 19:52'!value: aCollection 	"se resuelve con un método de PropositionalFormula para evitar repetir código"	^ super evaluar: aCollection operador: #==> argumentos: form1 y: form2! !!Implication methodsFor: 'initialization' stamp: 'GiselaConfalonieri 6/11/2016 17:59'!initImplof: aPropositionalFormula and: otherPropositionalFormula	form1 := aPropositionalFormula.	form2 := otherPropositionalFormula ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Implication class	instanceVariableNames: ''!!Implication class methodsFor: 'creating' stamp: 'GiselaConfalonieri 6/11/2016 17:58'!of: aPropositionalFormula and: otherPropositionalFormula	^ self new initImplof: aPropositionalFormula and: otherPropositionalFormula ! !PropositionalFormula subclass: #Negation	instanceVariableNames: 'form'	classVariableNames: ''	poolDictionaries: ''	category: 'PLPFormulaTests'!!Negation methodsFor: 'evaluating' stamp: 'GiselaConfalonieri 6/11/2016 19:11'!value: aCollection 	^ (form value: aCollection) not! !!Negation methodsFor: 'as yet unclassified' stamp: 'GiselaConfalonieri 6/13/2016 18:59'!negate	^ form! !!Negation methodsFor: 'as yet unclassified' stamp: 'GiselaConfalonieri 6/13/2016 17:54'!asString	^ '¬',(form comoString)! !!Negation methodsFor: 'as yet unclassified' stamp: 'GiselaConfalonieri 6/13/2016 17:37'!comoString	^ self asString! !!Negation methodsFor: 'as yet unclassified' stamp: 'GiselaConfalonieri 6/13/2016 19:41'!toNNF	^ form toNNF negate! !!Negation methodsFor: 'as yet unclassified' stamp: 'GiselaConfalonieri 6/11/2016 17:54'!allPropVars	^ form allPropVars! !!Negation methodsFor: 'initialization' stamp: 'GiselaConfalonieri 6/11/2016 16:33'!initNeg: aPropositionalVariable 	form := aPropositionalVariable ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Negation class	instanceVariableNames: ''!!Negation class methodsFor: 'creating' stamp: 'GiselaConfalonieri 6/11/2016 16:32'!of: aPropositionalFormula 	^ self new initNeg: aPropositionalFormula ! !PropositionalFormula subclass: #PropositionalVariable	instanceVariableNames: 'var'	classVariableNames: ''	poolDictionaries: ''	category: 'PLPFormulaTests'!!PropositionalVariable methodsFor: 'evaluating' stamp: 'GiselaConfalonieri 6/11/2016 18:37'!value: aCollection 	^ aCollection includes: var! !!PropositionalVariable methodsFor: 'initializing' stamp: 'GiselaConfalonieri 6/11/2016 16:27'!initVar: aString 	var := aString! !!PropositionalVariable methodsFor: 'as yet unclassified' stamp: 'GiselaConfalonieri 6/13/2016 18:57'!negate	^ self not! !!PropositionalVariable methodsFor: 'as yet unclassified' stamp: 'GiselaConfalonieri 6/13/2016 16:50'!asString	^ var asString! !!PropositionalVariable methodsFor: 'as yet unclassified' stamp: 'GiselaConfalonieri 6/13/2016 17:49'!comoString	^ self asString! !!PropositionalVariable methodsFor: 'as yet unclassified' stamp: 'GiselaConfalonieri 6/13/2016 19:40'!toNNF	^ self! !!PropositionalVariable methodsFor: 'as yet unclassified' stamp: 'GiselaConfalonieri 6/11/2016 17:38'!allPropVars	^ Set with: var! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PropositionalVariable class	instanceVariableNames: ''!!PropositionalVariable class methodsFor: 'creating' stamp: 'GiselaConfalonieri 6/11/2016 16:26'!named: aString 	^ self new initVar: aString! !